export type Locale = 'zh' | 'en'

export const translations: Record<Locale, Record<string, string>> = {
  zh: {
    'nav.home': '首页',
    'nav.createStore': '常规',
    'nav.manual': '使用',
    'nav.collections': '集合',
    'nav.subscribe': '订阅',
    'nav.performance': '性能',
    'nav.bestPractices': '实战',
    'nav.themeToLight': '切换到浅色',
    'nav.themeToDark': '切换到深色',
    'nav.langSwitch': '切换语言',
    'nav.github': '在 GitHub 上查看',
    'app.skipToMain': '跳到主内容',
    'app.footerNovaSkill': 'Nova Skill',
    'app.footerNovaSkillIntro': 'AI Skill 平台：创建与发布可复用的领域技能、工作流与工具集成',
    'app.footerEmpjs': 'EMPJS',
    'app.footerEmpjsIntro': 'EMP 团队官网与前端生态（含 @empjs/valtio 等）',
    'app.footer': '© 2026 EMP Team. MIT License.',
    'home.heroTitle': 'Valtio Enhanced Store',
    'home.heroDesc': 'Valtio 的强大增强版 —— 更少样板代码，更高生产力',
    'home.heroDeps': '依赖 React 18+，与 valtio、derive-valtio、valtio-history 一起使用。',
    'home.installTabs': '包管理器',
    'home.copy': '复制命令',
    'home.copied': '已复制',
    'home.cards.createStore': '常规',
    'home.cards.createStoreDesc': 'use()：统一 API，支持全局单例与局部状态（常规 / 历史 / 派生）',
    'home.cards.collections': 'collections',
    'home.cards.collectionsDesc': 'createMap / createSet',
    'home.cards.subscribe': 'subscribe',
    'home.cards.subscribeDesc': 'subscribeKey、subscribeKeys、batch、细粒度订阅',
    'home.cards.performance': 'performance',
    'home.cards.performanceDesc': '长列表：batch 批量操作、content-visibility',
    'home.cards.bestPractices': 'best-practices',
    'home.cards.bestPracticesDesc': 'TypeScript 最佳类型定义与组件通信模式',
    'home.advantagesTitle': '与原生 Valtio 相比的核心优势',
    'home.advantagesSub': '更少样板、更强类型、内置历史与派生，开箱即用',
    'home.adv.boilerplate.title': '极大减少样板代码',
    'home.adv.boilerplate.desc':
      '无需每次手动 proxy + useSnapshot + subscribe，store 直接拥有 set、update、reset、persist 等实用方法',
    'home.adv.typescript.title': '一流 TypeScript 支持',
    'home.adv.typescript.desc': '三种模式（普通 / 历史 / 派生）返回类型精确推导，几乎零 as 断言',
    'home.adv.derive.title': '一行代码派生状态',
    'home.adv.derive.desc': '通过 derive 选项自动生成响应式计算属性',
    'home.adv.undo.title': '内置完整撤销/重做',
    'home.adv.undo.desc': 'useSnapshot 直接返回 undo、redo、isUndoEnabled 等控制',
    'home.adv.persist.title': '持久化只需一行',
    'home.adv.persist.desc': "store.persist('key') 自动双向同步 localStorage",
    'home.adv.local.title': '组件内局部状态',
    'home.adv.local.desc': 'useStore Hook 支持 history / derive 模式，非常适合表单、编辑器、画板等场景',
    'home.adv.tools.title': '实用工具齐全',
    'home.adv.tools.desc': '深层路径更新、多键订阅、深克隆、智能 JSON 序列化、调试输出等',
    'home.adv.devtools.title': '开发友好',
    'home.adv.devtools.desc': '自动开启 DevTools，内置 createMap / createSet 集合代理',
    'home.docTitle': '用法导航',
    'home.docSectionTitle': '核心用法一览',
    'home.docSectionSub': 'use · collections · subscribe · performance —— 一点即达，即查即用',
    'common.instanceA': '实例 A',
    'common.instanceB': '实例 B',
    'common.instanceC': '实例 C',
    'common.undo': '撤销',
    'common.redo': '重做',
    'common.loading': 'Loading…',
    'common.notFound': '页面未找到',
    'common.notLoaded': '未加载',
    'common.reload': '重新加载',
    'common.loadUser': '加载用户',
    'common.demoResult': '运行效果',
    'common.renderCount': '渲染 #',
    'common.historySteps': '当前记录步数',
    'createStore.title': '常规',
    'createStore.intro':
      '统一的 use() API。传入函数返回对象即为局部 store (useStore)，传入对象则为全局 store (createStore)。支持常规、历史、派生、异步。',
    'createStore.signature': '签名：use(stateOrInit, options?) → [snap, store] (局部) 或 store (全局)',
    'createStore.codeTitle': '完整示例（常规 → 历史 → 派生 → 异步，含调用闭环与中文提示）',
    'createStore.codeTitlePrefix': '完整示例',
    'createStore.codeTitleSteps': '常规, 历史, 派生, 异步',
    'createStore.codeTitleSuffix': '含调用闭环与中文提示',
    'createStore.s1Title': '1. 常规用例',
    'createStore.s1Desc': 'Global: 多组件同步共享；Local: 组件内独立维护。',
    'createStore.s2Title': '2. 历史用例',
    'createStore.s2Desc': '内置撤销/重做 (history)，Global 同步历史，Local 独立历史。',
    'createStore.s3Title': '3. 派生用例',
    'createStore.s3Desc': '自动计算派生属性 (derive)，依赖变化自动更新。',
    'createStore.s4Title': '4. 异步用例',
    'createStore.s4Desc': '在 store 中处理异步逻辑，轻松管理 loading/error 状态。',
    'useStore.title': 'useStore',
    'useStore.intro':
      '在组件内创建局部 store，返回 [snap, store]。支持常规、带历史、带派生；异步请求用常规 store + 手动 loading/error。',
    'useStore.signature':
      '签名：useStore(initialState, options?) → [snap, store] 或 [baseSnap, baseStore, derivedSnap]（options.derive 时）',
    'useStore.codeTitle': '完整示例（常规 → 何时用 → 历史 → 派生 → 异步，含调用闭环与中文提示）',
    'useStore.codeTitlePrefix': '完整示例',
    'useStore.codeTitleSteps': '常规, 何时用, 历史, 派生, 异步',
    'useStore.codeTitleSuffix': '含调用闭环与中文提示',
    'useStore.s1Title': '1. 常规 useStore',
    'useStore.s1Desc': '每个实例内部 useStore，各自维护自己的 count，互不影响。',
    'useStore.s2Title': '2. 带历史的 useStore',
    'useStore.s2Desc': '每个实例内部 useStore，各自维护自己的 count 与历史，互不影响。',
    'useStore.s3Title': '3. 带派生的 useStore',
    'useStore.s3Desc': '每个实例内部 useStore + derive，各自维护自己的 a、b 与派生 sum，互不影响。',
    'useStore.s4Title': '4. 异步请求（局部 store）',
    'useStore.s4Desc': '每个实例内部 useStore，各自维护自己的 user / loading / error，互不影响。',
    'collections.title': 'collections',
    'collections.intro': 'createMap / createSet：可代理的 Map/Set，在 store 或组件内使用，增删改会触发订阅更新。',
    'collections.codeTitle': '完整示例（导入 → 创建 → 全局/局部使用与读/写闭环，含中文提示）',
    'collections.codeTitlePrefix': '完整示例',
    'collections.codeTitleSteps': '导入, 创建, 全局/局部使用与读/写闭环',
    'collections.codeTitleSuffix': '含中文提示',
    'collections.s1Title': '1. 全局 createStore（跨组件共享）',
    'collections.s1Desc': '同一全局 store，多处组件订阅同一 map/set，任意一处增删改会同步到所有实例。',
    'collections.s2Title': '2. 局部 useStore',
    'collections.s2Desc': '每个实例内部 useStore，各自维护自己的 map/set，互不影响。',
    'subscribe.title': 'subscribe',
    'subscribe.intro': 'subscribeKey / subscribeKeys、batch、以及 useSnapshot 的细粒度订阅（只读用到的字段）。',
    'subscribe.codeTitle': '完整示例（导入 → subscribeKey/Keys → batch → 细粒度订阅 → 何时用，含调用闭环与中文提示）',
    'subscribe.codeTitlePrefix': '完整示例',
    'subscribe.codeTitleSteps': '导入, subscribeKey/Keys, batch, 细粒度订阅, 何时用',
    'subscribe.codeTitleSuffix': '含调用闭环与中文提示',
    'subscribe.fineGrained': '细粒度订阅（只读 count / name，看渲染次数）',
    'subscribe.keyTitle': "subscribeKey('count')",
    'subscribe.keyDesc': '只监听 count 变化，改 name 不触发。',
    'subscribe.keysTitle': "subscribeKeys(['count','name'])",
    'subscribe.keysDesc': '监听 count 与 name，任一变化触发。',
    'subscribe.batchTitle': 'batch',
    'subscribe.batchDesc': '批量写合并为一次通知，细粒度组件只渲染一次。',
    'subscribe.keyLog': "subscribeKey('count') 日志",
    'subscribe.keysLog': "subscribeKeys(['count', 'name']) 日志",
    'subscribe.countPlus': 'count+1',
    'subscribe.nameToggle': 'name 切换',
    'subscribe.batchReset': 'batch reset',
    'performance.title': 'performance',
    'performance.intro':
      '长列表场景：用 batch 做批量增删改、content-visibility 优化渲染；大量数据可配合虚拟列表（如 virtua）。',
    'performance.codeTitle': '完整示例（batch 批量增删/全选 → content-visibility 渲染，含调用闭环与中文提示）',
    'performance.codeTitlePrefix': '完整示例',
    'performance.codeTitleSteps': 'batch 批量增删/全选, content-visibility 渲染',
    'performance.codeTitleSuffix': '含调用闭环与中文提示',
    'performance.demoTitle': '运行效果：长列表',
    'performance.totalItems': '共 {n} 条，用 batch 批量增删、content-visibility 优化渲染。',
    'performance.add100': '添加 100 条',
    'performance.remove100': '删除前 100 条',
    'performance.selectAll': '全选',
    'performance.deselectAll': '取消全选',
    'performance.itemDone': 'Item {id} 完成',
    'performance.s1Title': '1. 长列表与 Batch',
    'performance.s1Desc': '批量操作用 batch，列表项用 content-visibility 或虚拟滚动。',
    'performance.s2Title': '2. 细粒度更新（子组件）',
    'performance.s2Desc': '父组件输入，只有依赖该数据的子组件重渲染。',
    'performance.s3Title': '3. 瞬时更新（Ref）',
    'performance.s3Desc': '高频变化（如鼠标位置）使用 ref 避免组件频繁重渲染。',
    'performance.s4Title': '4. 派生计算缓存',
    'performance.s4Desc': '使用 derive 缓存昂贵计算，依赖不变时不重新计算。',
    'performance.childRender': '子组件渲染 #',
    'performance.parent': '父组件',
    'performance.child': '子组件',
    'performance.expensive': '昂贵计算结果',
    'performance.mouseMove': '在区域内移动鼠标',
    'performance.mousePos': '鼠标位置 (Ref)',
    'bestPractices.title': '最佳实战 (Best Practices)',
    'bestPractices.intro':
      '调用闭环、类型与选型、常规/全局/组件通信与常见错误，按实践优先级整理。',
    'bestPractices.seeManual': '方法说明与带注释代码见「使用」页。',
    'bestPractices.s1Title': '1. 调用闭环（必守）',
    'bestPractices.s1Desc':
      '读只用 snap，写用 store 方法；否则订阅不更新。历史 store：读 snap.value、写 store.value，撤销/重做 snap.undo() / snap.redo()。',
    'bestPractices.s2Title': '2. 类型：EmpStore<T>',
    'bestPractices.s2Desc':
      '用 EmpStore<T> 标注，不手写 interface；createStore/useStore 返回即 EmpStore。',
    'bestPractices.s3Title': '3. 选型：createStore vs useStore',
    'bestPractices.s3Desc': '单例、跨组件共享用 createStore；组件内每实例一份（表单、编辑器、画板）用 useStore。',
    'bestPractices.s4Title': '4. 常规 Store',
    'bestPractices.s4Desc':
      'createStore：模块单例，读 useSnapshot()、写 set/update。useStore：返回 [snap, store]，initialState 可为函数惰性初始化。',
    'bestPractices.s5Title': '5. 全局 Store',
    'bestPractices.s5Desc': '跨组件共享用 createStore，返回 EmpStore<T>（自动推导）。',
    'bestPractices.s6Title': '6. 组件通信（Parent → Child）',
    'bestPractices.s6Desc':
      '父 useStore 得 [snap, store]，将 store 传给子；子 props 收 EmpStore<MyState>，读 useSnapshot、写 set/reset。',
    'bestPractices.s7Title': '7. 常见错误与注意点',
    'bestPractices.s7Desc':
      'useSnapshot/subscribe 必须传 proxy；derive 返回纯对象、无副作用；集合 key 勿用 "set"。',
    'bestPractices.callFlowDemoTitle': '调用闭环：读 snap，写 store',
    'bestPractices.localStoreDemoTitle': '1.2 局部 Store：组件隔离',
    'bestPractices.enhancedStoreMethods': '传导方法',
    'bestPractices.localStoreDemoNote':
      '每实例独立 useStore，状态互不干扰；store 为 EmpStore，具备 set / update / reset / useSnapshot 等传导方法。',
    'bestPractices.compCommDemoTitle': '组件通信：Parent useStore → Child EmpStore',
    'bestPractices.codeTitle': '完整实战示例',
    'bestPractices.codeTitle1': '调用闭环 + 类型/选型 + 常规 + 组件通信',
    'bestPractices.codeTitle2': '常见错误与注意点',
    'manual.title': 'Store 方法使用手册',
    'manual.intro': 'createStore / useStore 获取 store，EmpStore 暴露 17 个方法；每节含说明与带注释结果的代码示例。',
    'manual.anchorNav': '方法导航',
    'manual.createStoreTitle': 'createStore',
    'manual.createStoreDesc': '模块级单例，跨组件共享。传入初始状态与可选 options，返回 EmpStore<T>。',
    'manual.useStoreTitle': 'useStore',
    'manual.useStoreDesc': '组件内每实例独立 store，返回 [snap, store]。可将 store 传导给子组件，子组件用 EmpStore<State> 类型接收，读 useSnapshot、写 set/reset。',
    'bestPractices.manualTitle': 'Store 方法使用手册',
    'bestPractices.method_useSnapshotTitle': 'useSnapshot()',
    'bestPractices.method_useSnapshotDesc': 'React Hook，组件内读状态；必守「读用 snap」，否则不触发订阅。签名：() => Snapshot<T>',
    'bestPractices.method_setTitle': 'set(key, value)',
    'bestPractices.method_setDesc': '单字段更新，最常用写。签名：(key, value) => void',
    'bestPractices.method_updateTitle': 'update(partial)',
    'bestPractices.method_updateDesc': '批量浅层更新，内部 Object.assign。签名：(partial: Partial<T>) => void',
    'bestPractices.method_resetTitle': 'reset(initialState)',
    'bestPractices.method_resetDesc': '清空数据字段后写入新状态，保留方法；表单/重置常用。签名：(initialState: T) => void',
    'bestPractices.method_subscribeTitle': 'subscribe(callback, notifyInSync?)',
    'bestPractices.method_subscribeDesc': '全量变更订阅；非 React 或副作用时用。返回 Unsubscribe。notifyInSync 可同步触发。',
    'bestPractices.method_subscribeKeyTitle': 'subscribeKey(key, callback)',
    'bestPractices.method_subscribeKeyDesc': '单 key 变更回调。返回 Unsubscribe。',
    'bestPractices.method_subscribeKeysTitle': 'subscribeKeys(keys, callback)',
    'bestPractices.method_subscribeKeysDesc': '多 key 订阅，callback(key, value)。返回 Unsubscribe。',
    'bestPractices.method_batchTitle': 'batch(fn)',
    'bestPractices.method_batchDesc': '多次写合并为一次通知，减少重渲染。签名：(fn: (store) => void) => void',
    'bestPractices.method_getSnapshotTitle': 'getSnapshot()',
    'bestPractices.method_getSnapshotDesc': '非 React 场景取当前只读快照，不触发订阅。签名：() => Snapshot<T>',
    'bestPractices.method_persistTitle': 'persist(key)',
    'bestPractices.method_persistDesc': '与 localStorage 双向同步；先读 key 恢复，再 subscribe 写回。返回 Unsubscribe。',
    'bestPractices.method_cloneTitle': 'clone()',
    'bestPractices.method_cloneDesc': 'deepClone 快照后新 proxy + enhanceStore，返回新 EmpStore。签名：() => T',
    'bestPractices.method_toJSONTitle': 'toJSON()',
    'bestPractices.method_toJSONDesc': '可序列化字段（去掉 function/symbol）。签名：() => Record<string, unknown>',
    'bestPractices.method_fromJSONTitle': 'fromJSON(json)',
    'bestPractices.method_fromJSONDesc': '从对象写回 store。签名：(json: Record<string, unknown>) => void',
    'bestPractices.method_setNestedTitle': 'setNested(path, value)',
    'bestPractices.method_setNestedDesc': '点号路径写入，如 "a.b.c"。签名：(path: string, value: unknown) => void',
    'bestPractices.method_deleteTitle': 'delete(key)',
    'bestPractices.method_deleteDesc': '删除字段。签名：(key) => void',
    'bestPractices.method_refTitle': 'ref(value)',
    'bestPractices.method_refDesc': 'valtio ref：存非代理值，不触发订阅。签名：<V>(value: V) => V',
    'bestPractices.method_debugTitle': 'debug(label?)',
    'bestPractices.method_debugDesc': 'console.group 打印当前快照，开发用。签名：(label?: string) => void',
  },
  en: {
    'nav.home': 'Home',
    'nav.createStore': 'Regular',
    'nav.manual': 'Use',
    'nav.collections': 'Collections',
    'nav.subscribe': 'Subscribe',
    'nav.performance': 'Performance',
    'nav.bestPractices': 'Best Practices',
    'nav.themeToLight': 'Switch to light',
    'nav.themeToDark': 'Switch to dark',
    'nav.langSwitch': 'Switch language',
    'nav.github': 'View on GitHub',
    'app.skipToMain': 'Skip to main content',
    'app.footerNovaSkill': 'Nova Skill',
    'app.footerNovaSkillIntro':
      'AI Skill platform: create and publish reusable domain skills, workflows and tool integrations',
    'app.footerEmpjs': 'EMPJS',
    'app.footerEmpjsIntro': 'EMP team site and frontend ecosystem (@empjs/valtio, etc.)',
    'app.footer': '© 2026 EMP Team. MIT License.',
    'home.heroTitle': 'Valtio Enhanced Store',
    'home.heroDesc': 'A powerful enhancement of Valtio — less boilerplate, more productivity.',
    'home.heroDeps': 'Requires React 18+, works with valtio, derive-valtio, valtio-history.',
    'home.installTabs': 'Package manager',
    'home.copy': 'Copy command',
    'home.copied': 'Copied',
    'home.cards.createStore': 'Regular',
    'home.cards.createStoreDesc': 'Global store: regular / history / derive, store.useSnapshot()',
    'home.cards.useStore': 'useStore',
    'home.cards.useStoreDesc': 'Local store: [snap, store], history / derive / async',
    'home.cards.collections': 'collections',
    'home.cards.collectionsDesc': 'createMap / createSet',
    'home.cards.subscribe': 'subscribe',
    'home.cards.subscribeDesc': 'subscribeKey, subscribeKeys, batch, fine-grained subscription',
    'home.cards.performance': 'performance',
    'home.cards.performanceDesc': 'Long lists: batch updates, content-visibility',
    'home.cards.bestPractices': 'best-practices',
    'home.cards.bestPracticesDesc': 'Best patterns for TypeScript types and component communication',
    'home.advantagesTitle': 'Key advantages over vanilla Valtio',
    'home.advantagesSub': 'Less boilerplate, stronger types, built-in history & derive, ready to use.',
    'home.adv.boilerplate.title': 'Much less boilerplate',
    'home.adv.boilerplate.desc':
      'No more manual proxy + useSnapshot + subscribe every time; store comes with set, update, reset, persist and more.',
    'home.adv.typescript.title': 'First-class TypeScript',
    'home.adv.typescript.desc':
      'Precise return types for all three modes (regular / history / derive), almost zero type assertions.',
    'home.adv.derive.title': 'Derived state in one line',
    'home.adv.derive.desc': 'Derive option auto-generates reactive computed state.',
    'home.adv.undo.title': 'Built-in undo/redo',
    'home.adv.undo.desc': 'useSnapshot returns undo, redo, isUndoEnabled and related controls directly.',
    'home.adv.persist.title': 'One-line persistence',
    'home.adv.persist.desc': "store.persist('key') syncs bidirectionally with localStorage.",
    'home.adv.local.title': 'Local component state',
    'home.adv.local.desc': 'useStore Hook supports history / derive, ideal for forms, editors, canvases.',
    'home.adv.tools.title': 'Rich utilities',
    'home.adv.tools.desc':
      'Nested path updates, multi-key subscription, deep clone, smart JSON serialization, debug output and more.',
    'home.adv.devtools.title': 'Dev-friendly',
    'home.adv.devtools.desc': 'DevTools enabled by default, built-in createMap / createSet proxies.',
    'home.docTitle': 'Documentation',
    'home.docSectionTitle': 'Core documentation',
    'home.docSectionSub': 'createStore · useStore · collections · subscribe · performance — one click away.',
    'common.instanceA': 'Instance A',
    'common.instanceB': 'Instance B',
    'common.instanceC': 'Instance C',
    'common.undo': 'Undo',
    'common.redo': 'Redo',
    'common.loading': 'Loading…',
    'common.notFound': 'Page not found',
    'common.notLoaded': 'Not loaded',
    'common.reload': 'Reload',
    'common.loadUser': 'Load user',
    'common.demoResult': 'Demo',
    'common.renderCount': 'render #',
    'common.historySteps': 'Steps',
    'createStore.title': 'Regular',
    'createStore.intro':
      'Create a global store, singleton shared across components. Supports regular, history, and derive; async with regular store + manual loading/error.',
    'createStore.signature':
      'Signature: createStore(initialState, options?) → store or { base, derived } (when options has history or derive)',
    'createStore.codeTitle': 'Full example (import → define → read/write → history → derive → async, with call flow)',
    'createStore.codeTitlePrefix': 'Full example',
    'createStore.codeTitleSteps': 'import, define, read/write, history, derive, async',
    'createStore.codeTitleSuffix': 'with call flow',
    'createStore.s1Title': '1. Regular createStore',
    'createStore.s1Desc':
      'Same global store, multiple components subscribe to the same count; +1 anywhere syncs to all.',
    'createStore.s2Title': '2. createStore with history',
    'createStore.s2Desc':
      'Same global store, two components subscribe to the same count; actions sync between instances.',
    'createStore.s3Title': '3. createStore with derive',
    'createStore.s3Desc': 'Same global store (base + derived), two components; changing a anywhere syncs derived sum.',
    'createStore.s4Title': '4. Async (global store)',
    'createStore.s4Desc':
      'Same global store, two components subscribe to user/loading/error; load in one syncs to the other.',
    'useStore.title': 'useStore',
    'useStore.intro':
      'Create a local store inside a component, returns [snap, store]. Supports regular, history, derive; async with regular store + manual loading/error.',
    'useStore.signature':
      'Signature: useStore(initialState, options?) → [snap, store] or [baseSnap, baseStore, derivedSnap] (when options.derive)',
    'useStore.codeTitle': 'Full example (regular → when to use → history → derive → async, with call flow)',
    'useStore.codeTitlePrefix': 'Full example',
    'useStore.codeTitleSteps': 'regular, when to use, history, derive, async',
    'useStore.codeTitleSuffix': 'with call flow',
    'useStore.s1Title': '1. Regular useStore',
    'useStore.s1Desc': 'Each instance uses useStore internally, each maintains its own count, independent.',
    'useStore.s2Title': '2. useStore with history',
    'useStore.s2Desc': 'Each instance uses useStore internally, each maintains its own count and history, independent.',
    'useStore.s3Title': '3. useStore with derive',
    'useStore.s3Desc':
      'Each instance uses useStore + derive, each maintains its own a, b and derived sum, independent.',
    'useStore.s4Title': '4. Async (local store)',
    'useStore.s4Desc':
      'Each instance uses useStore internally, each maintains its own user / loading / error, independent.',
    'collections.title': 'collections',
    'collections.intro':
      'createMap / createSet: proxy-able Map/Set, use in store or component; add/delete/update triggers subscription.',
    'collections.codeTitle': 'Full example (import → create → global/local use and read/write flow)',
    'collections.codeTitlePrefix': 'Full example',
    'collections.codeTitleSteps': 'import, create, global/local use and read/write flow',
    'collections.codeTitleSuffix': '',
    'collections.s1Title': '1. Global createStore (shared across components)',
    'collections.s1Desc':
      'Same global store, multiple components subscribe to the same map/set; add/delete/update anywhere syncs to all.',
    'collections.s2Title': '2. Local useStore',
    'collections.s2Desc': 'Each instance uses useStore internally, each maintains its own map/set, independent.',
    'subscribe.title': 'subscribe',
    'subscribe.intro':
      'subscribeKey / subscribeKeys, batch, and useSnapshot fine-grained subscription (only read used fields).',
    'subscribe.codeTitle':
      'Full example (import → subscribeKey/Keys → batch → fine-grained → when to use, with call flow)',
    'subscribe.codeTitlePrefix': 'Full example',
    'subscribe.codeTitleSteps': 'import, subscribeKey/Keys, batch, fine-grained, when to use',
    'subscribe.codeTitleSuffix': 'with call flow',
    'subscribe.fineGrained': 'Fine-grained subscription (read only count / name, see render count)',
    'subscribe.keyTitle': "subscribeKey('count')",
    'subscribe.keyDesc': 'Only listens to count; changing name does not trigger.',
    'subscribe.keysTitle': "subscribeKeys(['count','name'])",
    'subscribe.keysDesc': 'Listens to count and name; either change triggers.',
    'subscribe.batchTitle': 'batch',
    'subscribe.batchDesc': 'Batch writes into one notification; fine-grained components re-render once.',
    'subscribe.keyLog': "subscribeKey('count') log",
    'subscribe.keysLog': "subscribeKeys(['count', 'name']) log",
    'subscribe.countPlus': 'count+1',
    'subscribe.nameToggle': 'Toggle name',
    'subscribe.batchReset': 'batch reset',
    'performance.title': 'performance',
    'performance.intro':
      'Long lists: use batch for bulk add/remove/update, content-visibility for render; pair with virtual list (e.g. virtua) for large data.',
    'performance.codeTitle':
      'Full example (batch bulk add/remove/select all → content-visibility render, with call flow)',
    'performance.codeTitlePrefix': 'Full example',
    'performance.codeTitleSteps': 'batch bulk add/remove/select all, content-visibility render',
    'performance.codeTitleSuffix': 'with call flow',
    'performance.demoTitle': 'Demo: long list',
    'performance.totalItems': '{n} items, batch add/remove, content-visibility for render.',
    'performance.add100': 'Add 100',
    'performance.remove100': 'Remove first 100',
    'performance.selectAll': 'Select all',
    'performance.deselectAll': 'Deselect all',
    'performance.itemDone': 'Item {id} done',
    'performance.s1Title': '1. Long List & Batch',
    'performance.s1Desc': 'Bulk ops use batch, list items use content-visibility or virtual scroll.',
    'performance.s2Title': '2. Fine-grained (Child)',
    'performance.s2Desc': 'Parent input only re-renders dependent child components.',
    'performance.s3Title': '3. Transient (Ref)',
    'performance.s3Desc': 'High frequency (e.g. mouse) use ref to avoid re-renders.',
    'performance.s4Title': '4. Derived Memoization',
    'performance.s4Desc': 'Use derive to cache expensive computations.',
    'performance.childRender': 'Child render #',
    'performance.parent': 'Parent',
    'performance.child': 'Child',
    'performance.expensive': 'Expensive Result',
    'performance.mouseMove': 'Move mouse inside',
    'performance.mousePos': 'Mouse Pos (Ref)',
    'bestPractices.title': 'Best Practices',
    'bestPractices.intro':
      'Call flow, types, createStore vs useStore, regular/global store, parent–child communication, and common pitfalls, ordered by practice priority.',
    'bestPractices.seeManual': 'See Use page for method details and annotated code.',
    'bestPractices.s1Title': '1. Call flow (required)',
    'bestPractices.s1Desc':
      'Read only from snap, write via store methods; otherwise subscription does not update. History store: read snap.value, write store.value; undo/redo snap.undo() / snap.redo().',
    'bestPractices.s2Title': '2. Types: EmpStore<T>',
    'bestPractices.s2Desc':
      'Use EmpStore<T> for types; do not hand-write interfaces; createStore/useStore return EmpStore.',
    'bestPractices.s3Title': '3. Choice: createStore vs useStore',
    'bestPractices.s3Desc':
      'Singleton, shared across components: createStore; per-instance state (forms, editors, canvas): useStore.',
    'bestPractices.s4Title': '4. Regular store',
    'bestPractices.s4Desc':
      'createStore: module singleton, read useSnapshot(), write set/update. useStore: returns [snap, store], initialState can be a function for lazy init.',
    'bestPractices.s5Title': '5. Global store',
    'bestPractices.s5Desc': 'Use createStore for cross-component sharing; returns EmpStore<T> (inferred).',
    'bestPractices.s6Title': '6. Component communication (Parent → Child)',
    'bestPractices.s6Desc':
      'Parent useStore gets [snap, store], pass store to child; child props receive EmpStore<MyState>, read useSnapshot, write set/reset.',
    'bestPractices.s7Title': '7. Common pitfalls',
    'bestPractices.s7Desc':
      'Pass only proxy to useSnapshot/subscribe; derive returns plain object, no side effects; do not use key "set" for collections.',
    'bestPractices.callFlowDemoTitle': 'Call flow: read snap, write store',
    'bestPractices.localStoreDemoTitle': '1.2 Local Store: Component isolation',
    'bestPractices.enhancedStoreMethods': 'Conduction methods',
    'bestPractices.localStoreDemoNote':
      'Each instance uses useStore independently; state is isolated. Store is EmpStore with set, update, reset, useSnapshot.',
    'bestPractices.compCommDemoTitle': 'Component communication: Parent useStore → Child EmpStore',
    'bestPractices.codeTitle': 'Full example',
    'bestPractices.codeTitle1': 'Call flow + types/choice + regular + component communication',
    'bestPractices.codeTitle2': 'Common pitfalls',
    'manual.title': 'Store Methods Manual',
    'manual.intro': 'createStore / useStore to get a store; EmpStore exposes 17 methods; each section has description and code with comment results.',
    'manual.anchorNav': 'Method nav',
    'manual.createStoreTitle': 'createStore',
    'manual.createStoreDesc': 'Module-level singleton, shared across components. Pass initial state and optional options, returns EmpStore<T>.',
    'manual.useStoreTitle': 'useStore',
    'manual.useStoreDesc': 'Per-instance store inside a component, returns [snap, store]. Pass store to children; child receives EmpStore<State>, read via useSnapshot, write via set/reset.',
    'bestPractices.manualTitle': 'Store Methods Manual',
    'bestPractices.method_useSnapshotTitle': 'useSnapshot()',
    'bestPractices.method_useSnapshotDesc': 'React Hook for reading state in components; required "read from snap" or subscription does not trigger. Signature: () => Snapshot<T>',
    'bestPractices.method_setTitle': 'set(key, value)',
    'bestPractices.method_setDesc': 'Single-field update, most common write. Signature: (key, value) => void',
    'bestPractices.method_updateTitle': 'update(partial)',
    'bestPractices.method_updateDesc': 'Batch shallow update via Object.assign. Signature: (partial: Partial<T>) => void',
    'bestPractices.method_resetTitle': 'reset(initialState)',
    'bestPractices.method_resetDesc': 'Clear data fields then assign new state, methods preserved; common for forms/reset. Signature: (initialState: T) => void',
    'bestPractices.method_subscribeTitle': 'subscribe(callback, notifyInSync?)',
    'bestPractices.method_subscribeDesc': 'Subscribe to all changes; use outside React or for side effects. Returns Unsubscribe. notifyInSync for sync notify.',
    'bestPractices.method_subscribeKeyTitle': 'subscribeKey(key, callback)',
    'bestPractices.method_subscribeKeyDesc': 'Single-key change callback. Returns Unsubscribe.',
    'bestPractices.method_subscribeKeysTitle': 'subscribeKeys(keys, callback)',
    'bestPractices.method_subscribeKeysDesc': 'Multi-key subscription, callback(key, value). Returns Unsubscribe.',
    'bestPractices.method_batchTitle': 'batch(fn)',
    'bestPractices.method_batchDesc': 'Merge multiple writes into one notification, fewer re-renders. Signature: (fn: (store) => void) => void',
    'bestPractices.method_getSnapshotTitle': 'getSnapshot()',
    'bestPractices.method_getSnapshotDesc': 'Get current read-only snapshot outside React; does not trigger subscription. Signature: () => Snapshot<T>',
    'bestPractices.method_persistTitle': 'persist(key)',
    'bestPractices.method_persistDesc': 'Bidirectional sync with localStorage; restores from key then subscribe to write back. Returns Unsubscribe.',
    'bestPractices.method_cloneTitle': 'clone()',
    'bestPractices.method_cloneDesc': 'deepClone snapshot then new proxy + enhanceStore, returns new EmpStore. Signature: () => T',
    'bestPractices.method_toJSONTitle': 'toJSON()',
    'bestPractices.method_toJSONDesc': 'Serializable fields only (no function/symbol). Signature: () => Record<string, unknown>',
    'bestPractices.method_fromJSONTitle': 'fromJSON(json)',
    'bestPractices.method_fromJSONDesc': 'Write object into store. Signature: (json: Record<string, unknown>) => void',
    'bestPractices.method_setNestedTitle': 'setNested(path, value)',
    'bestPractices.method_setNestedDesc': 'Dot-path write, e.g. "a.b.c". Signature: (path: string, value: unknown) => void',
    'bestPractices.method_deleteTitle': 'delete(key)',
    'bestPractices.method_deleteDesc': 'Delete field. Signature: (key) => void',
    'bestPractices.method_refTitle': 'ref(value)',
    'bestPractices.method_refDesc': 'Valtio ref: store non-proxy value, no subscription. Signature: <V>(value: V) => V',
    'bestPractices.method_debugTitle': 'debug(label?)',
    'bestPractices.method_debugDesc': 'console.group current snapshot, for dev. Signature: (label?: string) => void',
  },
}
